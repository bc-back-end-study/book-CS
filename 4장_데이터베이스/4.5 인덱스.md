### 인덱스(index)

#### 인덱스(index)란?
 - 인덱스는 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상하기 위한 자료구조이다.
 - 컬럼에 인덱스를 생성하면, 해당 컬럼의 데이터들을 정렬하여 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장한다.
 
#### B-Tree
![image](https://user-images.githubusercontent.com/46198324/201251129-45d6c0cc-bee0-4a00-aa7d-5ab4796b1cb6.png)

 - 모든 리프 노드들이 같은 레벨을 가질 수 있도록 자동으로 균형을 맞추는 트리이다.
 - 최상위 노드를 루트 노드라고 한다.
 - 중간에 위치한 노드들을 브랜치 노드라고 한다.
 - 맨 말단에 위치한 노드를 리프 노드라고 한다.

직접 B-Tree 만들어보는 사이트
https://www.cs.usfca.edu/~galles/visualization/BTree.html


#### B+Tree
![image](https://user-images.githubusercontent.com/46198324/201251259-4bf1a7c0-d8b1-4ad9-80d1-072f8b1c9cda.png)

 - B+tree는 B-tree의 확장 개념이다.
 - 브랜치 노드에 key만 담아두고, data는 담지 않는다.
 - 오직 리프 노드에만 key와 data를 저장하고, 리프 노드끼리 Linked list로 연결되어 있다.

<img width="876" alt="image" src="https://user-images.githubusercontent.com/46198324/201252126-901c06fd-61a7-4814-97a7-cbf7d0d806b1.png">


#### 인덱스의 장점
 - 테이블을 조회하는 속도와 그에 따른 성능을 향상할 수 있다.
 - 전반적인 시스템의 부하를 줄일 수 있다.
 - 효율성 증대

#### 효율성 증대 종류
 - 조건 검색 Where 절의 효율성 : 인덱스 테이블은 데이터들이 정렬되어 저장되어 있기 때문에 해당 조건 (Where)에 맞는 데이터들을 빠르게 찾을 수 있다.
 - 정렬 Order by 절의 효율성 : 인덱스(Index)를 사용하면 Order by에 의한 Sort과정을 피할 수가 있다. (이미 index로 정렬이 되어 있기 때문에)
 - MIN, MAX의 효율적인 처리 : MIN값과 MAX값을 레코드의 시작 값과 끝 값 한건씩만 가져오면 되기에 FULL TABLE SCAN 작업이 필요 없다.

#### 인덱스의 단점
 - 테이블이 수정되면 인덱스도 수정되어야 한다.
 - 정렬된 상태를 계속 유지해야 한다.
 - 인덱스를 저장할 추가적인 공간이 필요하다. (DB의 약 10%에 해당하는 저장공간이 필요)
 - insert, delete, update를 수행할 때마다 index를 관리해야 하기 때문에 성능이 떨어진다.

#### 인덱스 관리
 - INSERT: 새로운 데이터에 대한 인덱스를 추가
 - DELETE: 삭제하는 데이터의 인덱스를 사용하지 않음으로 변경
 - UPDATE: 기존의 인덱스를 사용하지 않음으로 변경, 갱신된 데이터에 대해 인덱스를 추가
 - update, delete를 하기 위해 해당 데이터를 조회하는 것을 인덱스로 빠르게 수행하는 것이 가능하여 항상 성능이 떨어지는 것은 아니다. 
 

#### 인덱스 생성 전략

 - 인덱스를 생성할 때는 순서가 있고 생성 순서에 따라 인덱스 성능이 달라진다. ( 같음 > 정렬 > 다중 값 > 카디널리티)
 - 생성된 인덱스를 가장 효율적으로 사용하려면 데이터의 분포도가 좋고, 조건절에 호출 빈도가 높은 컬럼을 인덱스로 생성하는 것이 좋다. 

1. 어떤 값과 ==이나 equal이라는 쿼리로 비교되는 컬럼
2. 정렬을 쓰는 필드
3. 다중 값을 출력해야 하는 필드 ( >, < 등 많은 값을 출력해야 하는 쿼리에 필드)
4. 중복되는 데이터가 최소한인 컬럼 (분포도가 좋은 컬럼)

#### 인덱스(index)를 사용하면 좋은 경우
 - 규모가 작지 않은 테이블
 - INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
 - JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼
 - 데이터의 중복도가 낮은 컬럼


#### 결론
 - 필드에 인덱스를 무작정 다 설정하는 것은 좋지 않다.
 - 컬렉션에서 가져와야 하는 양이 많을수록 인덱스를 사용하는 것은 비효율적이다.
 - 인덱스는 검색에 최적화된 기능이기 때문에, 삽입, 삭제, 수정이 자주 일어나는 비즈니스 로직 혹은 테이블 사용 용도에 따라 인덱스 사용 여부를 신중하게 고려해야 한다.


#### 이미지 출처    
https://www.programiz.com/dsa/b-tree     
https://www.programiz.com/dsa/b-plus-tree
