## 5.2 선형 자료 구조

```
데이터를 순서대로 나열한 것으로 자료들 간의 앞뒤 관계가 1:1 선형이다.

[1]-[2]-[3]-[4]-[5]

배열, 리스트, 스택, 큐
```

# 📌5.2.1 연결 리스트

```
불연속적으로 존재하는 데이터를 서로 연결(link)한 형태로 구성되어 있다.
```

## 배열 vs 연결 리스트

배열은 기본적인 형태의 자료구조로 데이터를 읽는 시간(접근시간)이 가장 빠르다.  
단점은 크기를 변경할 수 없고 비순차적인 데이터의 추가, 삭제에 시간이 많이 걸린다.

:fire: 배열의 단점을 보완한 자료구조가 연결 리스트이다.  
연결 리스트는 크기를 미리 정할 필요가 없기 때문에 동적(dynamic)인 자료구조이다. 데이터들이 배열처럼 연속적으로 메모리에 저장되어 있지 않고도 선형구조로 데이터를 저장할 수 있다.

연결 리스트의 각 요소(node)들은 자신과 연결된 다음 요소에 대한 주소값과 데이터로 구성되어 있다.

```
연결 리스트의 요소 = 데이터 + 주소
```

---

### :one: 싱글 연결 리스트

- 이동방향이 단방향이기 때문에 다음 요소에 대한 접근은 쉽지만 이전 요소에 대한 접근은 어렵다.

```java
class Node{
    Node next; // 다음 요소의 주소를 저장
    Object obj; // 데이터를 저장
}
```

---

### :two: 이중 연결 리스트

- 이를 보완한 이중 연결 리스트는 참조변수를 하나 더 추가하여 이전 요소에 대한 참조를 가능하게 한다.

```java
class Node{
    Node next; // 다음 요소의 주소를 저장
    Node prev; // 이전 요소의 주소르 저장
    Object obj; // 데이터를 저장
}
```

첫 번째 요소의 prev와 마지막 요소의 next는 참조값이 null이다.

---

### :three: 원형 이중 연결 리스트

- 이중 연결 리스트의 첫 번째 요소와 마지막 요소를 서로 연결시킨 것이다.  
  ex. Tv의 마지막 채널을 증가시키면 처음 채널로 이동하고, 처음 채널에서 감소시키면 마지막 채널로 이동하는 것

---

## Java 컬렉션 프레임웍

List 인터페이스를 구현한 LinkedList 클래스는 이중 연결 리스트로 구현되어 있다.

- LinkedList 선언

```java
LinkedList list = new LinkedList();
```

- 데이터 추가

```java
// 데이터 추가
list.add(3);
// 맨 앞에 데이터 추가
list.addFirst(1);
// 맨 뒤에 데이터 추가
list.addLast(2);
// 특정 인덱스에 데이터 추가
list.add(1,10);
```

- 데이터 삭제

```java
// 맨 앞에 데이터 삭제
list.removeFirst();
// 맨 뒤에 데이터 삭제
list.removeLast();
// 인덱스 1에 있는 값 삭제
list.remove(1);
// 생략시 0번째 인덱스 삭제
list.remove();
// 전체 삭제
list.clear();
```

- 데이터 출력

```java
// 특정 데이터 바로 출력
System.out.println(list.get(0));
// 반복문을 통한 전체 출력
for(Integer i : list){
    System.out.println(i);
}
```

---

## 시간복잡도(이중 연결 리스트)

- 데이터 탐색 : O(n)  
  연결 리스트는 연속적으로 메모리 주소를 할당받지 않기 때문에 임의 접근이 불가능하다. 데이터를 탐색하기 위해 순차적으로 탐색해야 한다.

- 데이터 추가/삭제 : O(n)? O(1)?  
  데이터를 추가하는 행위 자체는 O(1)이다. 연결된 주소값만 변경해주면 되기 때문에. 전제 조건은 추가하려는 위치의 이전 노드를 알 경우이다.  
  모르는 경우 조회하여 해당 위치까지 가야하므로 O(n)이 된다.

---

## 🙏정리하면서 궁금했던 점

연결 리스트는 배열에 비해 삽입과 삭제에 용이한데, 해당 노드까지 가기 위해 순차적으로 접근해야 한다면 시간복잡도는 O(n)이라고 한다. 그럼에도 배열보다 삽입/삭제가 빠르다는 이유가 무엇일까?
